<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Francisco Castro Zuleta | DESARROLLADOR XR (VR + Selector de Texturas)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body { margin:0; overflow:hidden; background:#f0f0f0; }
    #blocker {
      position:absolute; inset:0; background:rgba(0,0,0,.5);
      display:flex; align-items:center; justify-content:center;
      color:#fff; font-size:18px; z-index:10;
    }
    #copyBtn {
      position:fixed; top:10px; right:10px; z-index:5;
      padding:10px 14px; background:#08f; color:#fff; border:0; border-radius:6px; cursor:pointer;
    }
    #jsonInput { display:none; }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.module.js",
        "three/addons/": "./jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="blocker">
    <div>
      <p><b>Click para comenzar (modo desktop)</b></p>
      <p>W A S D para moverse, mouse para mirar • Click: añadir • Shift+Click: borrar • Q/E subir/bajar</p>
      <p>En VR: menú 3D con Añadir/Borrar, Texturas (miniaturas), Importar/Exportar JSON, Salir</p>
    </div>
  </div>

  <button id="copyBtn">Exportar JSON</button>
  <input id="jsonInput" type="file" accept=".json,application/json" />

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
    import { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';
    import { OculusHandPointerModel } from 'three/addons/webxr/OculusHandPointerModel.js';
    import { createText } from 'three/addons/webxr/Text2D.js';
    import { Water } from 'three/addons/objects/Water.js';
    import { Sky } from 'three/addons/objects/Sky.js';

    /* ====== CONSTANTES & GLOBALES ====== */
    const voxelSize = 20;
    const moveFlags = { forward:false, backward:false, left:false, right:false, up:false, down:false };
    const DESKTOP_SPEED = 10000;
    const clock = new THREE.Clock();

    let camera, scene, renderer, controls;
    let plane, raycaster, pointer;
    let rollOverMesh, cubeGeo;
    const objects = [];          // plano + cubos
    const cubesOnly = new Set();

    let water, sky, sun;

    // Texturas
    const tl = new THREE.TextureLoader();
    const textures = {
      arena: tl.load('textures/textura_arena.png'),
      madera: tl.load('textures/textura_wood.jpg'),
      hojas: tl.load('textures/textura_hojas.png'),
      blanco: tl.load('textures/textura_piso.jpg'),
      negro: tl.load('textures/textura_tec_negra.png'),
      ladrillo: tl.load('textures/textura_brick_2.jpg'),
      baldosaGris: tl.load('textures/textura_baldosaGris.jpg'),
      pisoVerde: tl.load('textures/textura_pisoVerde.jpg'),
      tejasAzules: tl.load('textures/textura_tejasAzules.jpg'),
      metal1: tl.load('textures/textura_metal1.jpg'),
      ladrillo2: tl.load('textures/textura_ladrillo2.jpg'),
      ladrillo3: tl.load('textures/textura_ladrillo3.jpg'),
      ladrillo4: tl.load('textures/textura_ladrillo4.jpg'),
      baldosaCafe: tl.load('textures/textura_baldosaCafe.jpg'),
      corteza: tl.load('textures/textura_corteza2.jpg'),
      madera2: tl.load('textures/textura_madera2.jpg'),
      madera3: tl.load('textures/textura_madera3.jpg'),
      gafas: tl.load('textures/textura_gafas.png')
    };
    Object.values(textures).forEach(t => t.colorSpace = THREE.SRGBColorSpace);
    const textureKeys = Object.keys(textures);
    let currentTextureIndex = Math.max(0, textureKeys.indexOf('madera'));
    let deleteMode = false;

    // VR entradas
    const controllerModelFactory = new XRControllerModelFactory();
    const controllers = []; // {grip, controller, hand, pointer}
    const tmpMatrix = new THREE.Matrix4();

    // VR UI
    const vrButtons = []; // elementos clicables (botones y miniaturas)
    let texSwatchMesh = null;
    let texNameText = null;

    // Panel de miniaturas
    let texPanel = null;
    let texTiles = [];     // miniaturas (meshes) clicables
    let texPage = 0;       // página actual del grid
    const TEX_PER_PAGE = 9;

    init();
    animate();

    /* ====== INIT ====== */
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 10000);

      // Luces
      scene.add(new THREE.AmbientLight(0x606060));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(1, 0.75, 0.5).normalize();
      dirLight.castShadow = true;
      scene.add(dirLight);

      // Grilla, plano, rollover
      cubeGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
      rollOverMesh = new THREE.Mesh(
        cubeGeo,
        new THREE.MeshBasicMaterial({ color: 0x44ff00, opacity: .45, transparent: true })
      );
      scene.add(rollOverMesh);

      scene.add(new THREE.GridHelper(1000, 1000 / voxelSize));
      const planeGeo = new THREE.PlaneGeometry(1000, 1000);
      planeGeo.rotateX(-Math.PI / 2);
      plane = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ visible: false }));
      plane.frustumCulled = false;
      scene.add(plane);
      objects.push(plane);

      // Agua & cielo
      const waterGeo = new THREE.PlaneGeometry(10000, 10000);
      water = new Water(waterGeo, {
        textureWidth: 512, textureHeight: 512,
        waterNormals: tl.load('textures/waternormals.jpg', t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; }),
        sunDirection: new THREE.Vector3(), sunColor: 0xffffff, waterColor: 0x144fff,
        distortionScale: 3.7, fog: scene.fog !== undefined
      });
      water.rotation.x = -Math.PI / 2;
      water.position.y = 2;
      scene.add(water);

      sky = new Sky();
      sky.scale.setScalar(10000);
      scene.add(sky);

      sun = new THREE.Vector3();
      updateSun(2, 180);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.xr.enabled = true;
      renderer.xr.cameraAutoUpdate = false;
      document.body.appendChild(renderer.domElement);

      // Desktop PointerLock
      controls = new PointerLockControls(camera, document.body);
      scene.add(controls.getObject());
      controls.getObject().position.set(0, voxelSize * 2, 0);

      document.getElementById('blocker').addEventListener('click', () => controls.lock());
      controls.addEventListener('lock', () => document.getElementById('blocker').style.display = 'none');
      controls.addEventListener('unlock', () => document.getElementById('blocker').style.display = 'flex');

      // Botón XR (con hand-tracking)
      document.body.appendChild(VRButton.createButton(renderer, {
        requiredFeatures: ['local-floor', 'hand-tracking']
      }));

      // Manos y controladores
      setupXRHandsAndControllers();

      // Menú VR principal y panel de texturas
      const menu = buildVRMenu();
      scene.add(menu);
      texPanel = buildTextureGridPanel();
      texPanel.visible = false;
      scene.add(texPanel);

      // Raycaster desktop
      raycaster = new THREE.Raycaster();
      pointer = new THREE.Vector2();

      // Eventos desktop
      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerdown', onPointerDown);
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      window.addEventListener('resize', onResize);

      // Botones DOM
      document.getElementById('copyBtn').addEventListener('click', exportCubes);
      document.getElementById('jsonInput').addEventListener('change', onImportFileSelected);

      // Carga inicial opcional
      fetch('./cubes.json').then(r => r.json()).then(cargarDesdeJSON).catch(()=>{});
    }

    function setupXRHandsAndControllers() {
      for (let i = 0; i < 2; i++) {
        const controllerGrip = renderer.xr.getControllerGrip(i);
        controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
        scene.add(controllerGrip);

        const controller = renderer.xr.getController(i);
        controller.add(makeControllerRay());
        controller.addEventListener('selectstart', onXRSelect);
        scene.add(controller);

        const hand = renderer.xr.getHand(i);
        hand.add(new OculusHandModel(hand));
        const handPointer = new OculusHandPointerModel(hand, controller);
        hand.add(handPointer);
        scene.add(hand);

        controllers.push({ grip: controllerGrip, controller, hand, pointer: handPointer });
      }
    }

    /* ====== MENÚ VR PRINCIPAL ====== */
    function buildVRMenu() {
      const root = new THREE.Group();
      root.position.set(0.45, 1.1, -1.0);
      root.rotation.y = -Math.PI/12;

      const plate = new THREE.Mesh(
        new THREE.PlaneGeometry(0.32, 0.78),
        new THREE.MeshPhongMaterial({ color: 0x000000, transparent:true, opacity: 0.18 })
      );
      root.add(plate);

      const makeButton = (label, color, y, action, w=0.26, h=0.11) => {
        const btn = new THREE.Mesh(
          new THREE.BoxGeometry(w, h, 0.012),
          new THREE.MeshPhongMaterial({ color })
        );
        btn.position.set(0, y, 0);
        btn.userData.action = action;
        const txt = createText(typeof label === 'function' ? label() : label, 0.045);
        txt.position.set(0, 0, 0.007);
        btn.add(txt);
        btn.userData.labelText = txt;
        plate.add(btn);
        vrButtons.push(btn);
        return btn;
      };

      // Toggle Añadir/Borrar
      const toggleBtn = makeButton(() => deleteMode ? 'Modo: BORRAR' : 'Modo: AÑADIR', 0x355c7d, 0.28, () => {
        deleteMode = !deleteMode;
        toggleBtn.material.color.set(deleteMode ? 0xc0392b : 0x355c7d);
        toggleBtn.userData.labelText.text = deleteMode ? 'Modo: BORRAR' : 'Modo: AÑADIR';
      });

      // Swatch y nombre
      const swatchW = 0.14, swatchH = 0.09;
      const swatchBG = new THREE.Mesh(new THREE.PlaneGeometry(swatchW+0.012, swatchH+0.012),
        new THREE.MeshBasicMaterial({ color: 0x111111, transparent:true, opacity:0.5 }));
      swatchBG.position.set(0, 0.14, 0.0065);
      plate.add(swatchBG);

      const swatch = new THREE.Mesh(
        new THREE.PlaneGeometry(swatchW, swatchH),
        new THREE.MeshBasicMaterial({ map: textures[textureKeys[currentTextureIndex]] })
      );
      swatch.position.set(0, 0.14, 0.007);
      plate.add(swatch);
      texSwatchMesh = swatch;

      texNameText = createText(textureKeys[currentTextureIndex], 0.035);
      texNameText.position.set(0, 0.06, 0.0065);
      plate.add(texNameText);

      // Botón para abrir/cerrar panel de miniaturas
      makeButton('Texturas…', 0xe67e22, 0.0, () => {
        texPanel.visible = !texPanel.visible;
        if (texPanel.visible) updateTextureGrid();
      });

      // Importar / Exportar
      makeButton('Importar JSON', 0x27ae60, -0.14, () => {
        const input = document.getElementById('jsonInput');
        input.value = '';
        input.click();
      });

      makeButton('Exportar JSON', 0x2980b9, -0.28, () => exportCubes());

      // Salir
      makeButton('Salir', 0xe74c3c, -0.42, () => {
        const session = renderer.xr.getSession();
        if (session) session.end();
      });

      return root;
    }

    /* ====== PANEL 3×3 DE MINIATURAS ====== */
    function buildTextureGridPanel() {
      // Grupo colocado frente a la cámara, un poco más a la derecha
      const g = new THREE.Group();
      g.position.set(0.0, 1.1, -1.05);
      g.rotation.y = 0;

      const plate = new THREE.Mesh(
        new THREE.PlaneGeometry(0.55, 0.70),
        new THREE.MeshPhongMaterial({ color: 0x000000, transparent:true, opacity: 0.22 })
      );
      g.add(plate);

      // Título
      const title = createText('Seleccionar textura', 0.045);
      title.position.set(0, 0.30, 0.0065);
      plate.add(title);

      // Botones de paginación y cerrar
      const makeBtn = (label, x, y, action, w=0.12, h=0.08, color=0x666666) => {
        const btn = new THREE.Mesh(
          new THREE.BoxGeometry(w, h, 0.012),
          new THREE.MeshPhongMaterial({ color })
        );
        btn.position.set(x, y, 0);
        btn.userData.action = action;
        const txt = createText(label, 0.04);
        txt.position.set(0, 0, 0.007);
        btn.add(txt);
        plate.add(btn);
        vrButtons.push(btn);
        return btn;
      };

      makeBtn('◀', -0.20, -0.30, () => { if (texPage > 0) { texPage--; updateTextureGrid(); } });
      makeBtn('▶',  0.20, -0.30, () => {
        const maxPage = Math.max(0, Math.ceil(textureKeys.length / TEX_PER_PAGE) - 1);
        if (texPage < maxPage) { texPage++; updateTextureGrid(); }
      });
      makeBtn('Cerrar', 0, -0.30, () => { g.visible = false; }, 0.18, 0.08, 0x8e44ad);

      // Grid 3×3
      const rows = 3, cols = 3;
      const cellW = 0.14, cellH = 0.14;
      const startX = -((cols - 1) * cellW) / 2;
      const startY =  0.16;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const frame = new THREE.Mesh(
            new THREE.PlaneGeometry(0.13, 0.13),
            new THREE.MeshBasicMaterial({ color: 0x111111, transparent:true, opacity:0.55 })
          );
          frame.position.set(startX + c * cellW, startY - r * cellH, 0.006);
          plate.add(frame);

          const tile = new THREE.Mesh(
            new THREE.PlaneGeometry(0.11, 0.11),
            new THREE.MeshBasicMaterial({ map: null })
          );
          tile.position.set(0, 0, 0.001);
          frame.add(tile);

          // Borde de selección
          const border = new THREE.Mesh(
            new THREE.PlaneGeometry(0.125, 0.125),
            new THREE.MeshBasicMaterial({ color: 0xffff00, transparent:true, opacity:0.0 })
          );
          border.position.set(0, 0, 0.0005);
          frame.add(border);

          tile.userData.border = border;
          texTiles.push(tile);
          vrButtons.push(frame); // hacemos clic en el frame (padre) para facilidad
          frame.userData.tileRef = tile; // referencia para recuperar index
        }
      }

      return g;
    }

    function updateTextureGrid() {
      // Rellena 3×3 con las texturas de la página actual
      const start = texPage * TEX_PER_PAGE;
      for (let i = 0; i < texTiles.length; i++) {
        const tile = texTiles[i];
        const texIndex = start + i;
        const valid = texIndex < textureKeys.length;
        tile.visible = tile.parent.visible = valid;

        if (valid) {
          const key = textureKeys[texIndex];
          tile.material.map = textures[key];
          tile.material.needsUpdate = true;

          // Marcar selección actual
          const isSelected = (texIndex === currentTextureIndex);
          tile.userData.border.material.opacity = isSelected ? 0.9 : 0.0;

          // Guardamos acción de clic en el frame contenedor
          tile.parent.userData.action = () => {
            currentTextureIndex = texIndex;
            // Actualiza selección visual
            texTiles.forEach(t => t.userData.border.material.opacity = 0.0);
            tile.userData.border.material.opacity = 0.9;
            // Sincroniza swatch y nombre en menú principal
            texSwatchMesh.material.map = textures[textureKeys[currentTextureIndex]];
            texSwatchMesh.material.needsUpdate = true;
            texNameText.text = textureKeys[currentTextureIndex];
          };
        }
      }
    }

    /* ====== HELPERS ====== */
    function makeControllerRay() {
      const geometry = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]);
      const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ linewidth: 2 }));
      line.name = 'ray';
      line.scale.z = 1.6;
      return line;
    }

    function snap(v) {
      return v.clone().divideScalar(voxelSize).floor().multiplyScalar(voxelSize).addScalar(voxelSize/2);
    }

    function createVoxelAt(pos) {
      for (const c of cubesOnly) if (c.position.equals(pos)) return;
      const mat = new THREE.MeshLambertMaterial({ map: textures[textureKeys[currentTextureIndex]] });
      const voxel = new THREE.Mesh(cubeGeo, mat);
      voxel.position.copy(pos);
      scene.add(voxel);
      cubesOnly.add(voxel);
      objects.push(voxel);
      return voxel;
    }

    function deleteVoxel(obj) {
      if (obj !== plane && cubesOnly.has(obj)) {
        scene.remove(obj);
        cubesOnly.delete(obj);
        const i = objects.indexOf(obj);
        if (i >= 0) objects.splice(i, 1);
      }
    }

    function exportCubes() {
      const data = Array.from(cubesOnly).map(o => {
        const key = Object.entries(textures).find(([k,v]) => v === o.material.map)?.[0] ?? 'desconocida';
        return { x:o.position.x, y:o.position.y, z:o.position.z, textura:key };
      });
      const json = JSON.stringify(data, null, 2);
      navigator.clipboard.writeText(json).catch(()=>{});
      const blob = new Blob([json], { type:'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `escena_${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    function cargarDesdeJSON(arr) {
      // borrar cubos actuales
      for (const c of Array.from(cubesOnly)) deleteVoxel(c);
      // crear
      arr.forEach(({ x, y, z, textura }) => {
        const mat = new THREE.MeshLambertMaterial({ map: textures[textura] || null });
        const voxel = new THREE.Mesh(cubeGeo, mat);
        voxel.position.set(x, y, z);
        scene.add(voxel);
        cubesOnly.add(voxel);
        objects.push(voxel);
      });
    }

    function onImportFileSelected(e) {
      const file = e.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        try {
          const data = JSON.parse(evt.target.result);
          if (!Array.isArray(data)) { alert('El JSON debe ser un array de {x,y,z,textura}'); return; }
          cargarDesdeJSON(data);
        } catch (err) {
          console.error(err);
          alert('JSON no válido');
        }
      };
      reader.readAsText(file);
    }

    function updateSun(elevationDeg, azimuthDeg) {
      const phi = THREE.MathUtils.degToRad(90 - elevationDeg);
      const theta = THREE.MathUtils.degToRad(azimuthDeg);
      sun.setFromSphericalCoords(1, phi, theta);
      sky.material.uniforms.sunPosition.value.copy(sun);
      water.material.uniforms.sunDirection.value.copy(sun).normalize();
    }

    /* ====== INTERACCIÓN DESKTOP ====== */
    function onPointerMove(e) {
      if (renderer.xr.isPresenting) return;
      pointer.set((e.clientX/innerWidth)*2-1, -(e.clientY/innerHeight)*2+1);
      raycaster.setFromCamera(pointer, camera);
      const hit = raycaster.intersectObjects(objects, false)[0];
      if (hit) {
        const pos = hit.point.clone().addScaledVector(hit.face.normal, voxelSize/2 + 0.01);
        rollOverMesh.position.copy(snap(pos));
      }
    }

    function onPointerDown(e) {
      if (renderer.xr.isPresenting) return;
      pointer.set((e.clientX/innerWidth)*2-1, -(e.clientY/innerHeight)*2+1);
      raycaster.setFromCamera(pointer, camera);
      const hit = raycaster.intersectObjects(objects, false)[0];
      if (!hit) return;
      if (e.shiftKey) { deleteVoxel(hit.object); return; }
      const pos = hit.point.clone().addScaledVector(hit.face.normal, voxelSize/2 + 0.01);
      createVoxelAt(snap(pos));
    }

    function onKeyDown(e) {
      switch (e.code) {
        case 'KeyW': moveFlags.forward = true; break;
        case 'KeyS': moveFlags.backward = true; break;
        case 'KeyA': moveFlags.left = true; break;
        case 'KeyD': moveFlags.right = true; break;
        case 'KeyQ': moveFlags.up = true; break;
        case 'KeyE': moveFlags.down = true; break;
      }
    }
    function onKeyUp(e) {
      switch (e.code) {
        case 'KeyW': moveFlags.forward = false; break;
        case 'KeyS': moveFlags.backward = false; break;
        case 'KeyA': moveFlags.left = false; break;
        case 'KeyD': moveFlags.right = false; break;
        case 'KeyQ': moveFlags.up = false; break;
        case 'KeyE': moveFlags.down = false; break;
      }
    }

    /* ====== INTERACCIÓN VR ====== */
    function onXRSelect(ev) {
      const controller = ev.target;
      const hit = controllerRaycast(controller);
      if (!hit) return;

      // ¿tocó un botón/miniatura? (el botón puede ser el mesh o su hijo)
      const targetBtn = findVRButtonFromHit(hit.object);
      if (targetBtn?.userData?.action) { targetBtn.userData.action(); return; }

      // Interacción con escena
      if (deleteMode && hit.object !== plane) {
        deleteVoxel(hit.object);
      } else {
        const pos = hit.point.clone().addScaledVector(hit.face.normal, voxelSize/2 + 0.01);
        createVoxelAt(snap(pos));
      }
    }

    function processHands() {
      for (const { pointer } of controllers) {
        if (!pointer) continue;
        const hit = handPointerIntersect(pointer);
        if (!hit) continue;

        pointer.setCursor(hit.distance);

        if (pointer.isPinched()) {
          const targetBtn = findVRButtonFromHit(hit.object);
          if (targetBtn?.userData?.action) { targetBtn.userData.action(); continue; }

          if (deleteMode && hit.object !== plane) {
            deleteVoxel(hit.object);
          } else {
            const pos = hit.point.clone().addScaledVector(hit.face.normal, voxelSize/2 + 0.01);
            createVoxelAt(snap(pos));
          }
        }
      }
    }

    function controllerRaycast(controller) {
      const rayOrigin = new THREE.Vector3();
      const rayDir = new THREE.Vector3(0, 0, -1);
      controller.updateMatrixWorld();
      rayOrigin.setFromMatrixPosition(controller.matrixWorld);
      rayDir.applyMatrix4(tmpMatrix.copy(controller.matrixWorld).extractRotation(controller.matrixWorld)).normalize();

      const rc = new THREE.Raycaster(rayOrigin, rayDir, 0, 10);
      // botones/miniaturas primero
      const uiHits = rc.intersectObjects(vrButtons, true);
      if (uiHits.length) return uiHits[0];
      // luego escena
      const hits = rc.intersectObjects(objects, false);
      return hits[0];
    }

    function handPointerIntersect(handPointer) {
      let closest = null;
      let dist = Infinity;

      for (const b of vrButtons) {
        const h = handPointer.intersectObject(b, true);
        if (h && h.length && h[0].distance < dist) { dist = h[0].distance; closest = h[0]; }
      }
      for (const obj of objects) {
        const h = handPointer.intersectObject(obj, false);
        if (h && h.length && h[0].distance < dist) { dist = h[0].distance; closest = h[0]; }
      }
      if (!closest) handPointer.setCursor(1.5);
      return closest;
    }

    function findVRButtonFromHit(obj) {
      // El objetivo puede ser el frame (botón) o un hijo (texto/tile)
      let cur = obj;
      while (cur) {
        if (vrButtons.includes(cur)) return cur;
        // si es un frame de miniatura, reenrutar a su acción de tile
        if (cur.userData?.tileRef && cur.userData?.action) return cur;
        cur = cur.parent;
      }
      return null;
    }

    /* ====== LOOP ====== */
    function animate() {
      const dt = clock.getDelta();

      // Desktop
      if (!renderer.xr.isPresenting && controls.isLocked) {
        const v = new THREE.Vector3(0,0,0);
        if (moveFlags.forward) v.z += DESKTOP_SPEED * dt;
        if (moveFlags.backward) v.z -= DESKTOP_SPEED * dt;
        if (moveFlags.left) v.x -= DESKTOP_SPEED * dt;
        if (moveFlags.right) v.x += DESKTOP_SPEED * dt;
        if (moveFlags.up) v.y += DESKTOP_SPEED * dt;
        if (moveFlags.down) v.y -= DESKTOP_SPEED * dt;
        controls.moveRight(v.x * dt);
        controls.moveForward(v.z * dt);
        controls.getObject().position.y += v.y * dt;
      }

      // VR
      renderer.xr.updateCamera(camera);
      processHands();

      if (water) water.material.uniforms.time.value += dt;

      renderer.render(scene, camera);
      renderer.setAnimationLoop(animate);
    }

    /* ====== Miscelánea ====== */
    function onResize() {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }
  </script>
</body>
</html>
