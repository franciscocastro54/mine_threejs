<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js - voxel FPS con ocean shader</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #f0f0f0;
    }

    /* Simple crosshair */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 10px;
      height: 10px;
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      pointer-events: none;
      z-index: 5;
    }

    .hidden {
      display: none !important;
    }

    /* Joysticks */
    .joystick {
      position: fixed;
      width: 120px;
      height: 120px;
      background: rgba(0, 0, 0, .35);
      border: 2px solid rgba(255, 255, 255, .5);
      border-radius: 50%;
      touch-action: none;
      user-select: none;
    }

    #left-joystick {
      left: 20px;
      bottom: 20px;
    }

    #right-joystick {
      right: 20px;
      bottom: 20px;
    }

    .knob {
      position: absolute;
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, .7);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, .5);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 20px;
      z-index: 100;
    }

    #instructions {
      text-align: center;
      max-width: 600px;
    }

    #copyBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 200;
      padding: 10px 15px;
      font-size: 14px;
      background: #08f;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    /* Mobileâ€‘only cube button */
    #addCubeBtn {
      position: fixed;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 120px;
      border-radius: 60px;
      background: #08f;
      color: #fff;
      font-size: 16px;
      border: none;
      z-index: 300;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
    }
  </style>
</head>

<body>
  <div id="crosshair"></div>
  <div id="joystick-container" class="hidden">
    <div id="left-joystick" class="joystick">
      <div id="left-knob" class="knob"></div>
    </div>
    <div id="right-joystick" class="joystick">
      <div id="right-knob" class="knob"></div>
    </div>
  </div>
  <div id="blocker">
    <div id="instructions">
      <p><b>Haz clic para comenzar</b></p>
      <p>W A S D para moverse, mouse para mirar</p>
      <p>Click: aÃ±adir cubo, Shift+Click: eliminar cubo</p>
      <p>Q / E para subir/bajar</p>
      <p>ESC pausa/configuraciÃ³n</p>
    </div>
  </div>
  <button id="copyBtn">Copiar coordenadas</button>
  <!-- ðŸ™‚ Este botÃ³n solo se mostrarÃ¡ en dispositivos mÃ³viles -->
  <button id="addCubeBtn" class="hidden">AÃ±adir&nbsp;Cubo</button>

  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.module.js",
        "three/addons/": "./jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js?module';
    import { Water } from 'three/addons/objects/Water.js';
    import { Sky } from 'three/addons/objects/Sky.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

    /* ----- CONSTANTS & GLOBALS ----- */
    const voxelSize = 20;
    const moveFlags = { forward: false, backward: false, left: false, right: false, up: false, down: false };
    const velocity = new THREE.Vector3();
    const DESKTOP_SPEED = 10000;
    const MOBILE_SPEED = 9000;

    const isMobile = window.matchMedia('(pointer: coarse)').matches;
    const clock = new THREE.Clock(); //  ðŸŒŸ  creado ANTES de animate()

    let camera, scene, renderer, controls;
    let plane, pointer, raycaster, isShiftDown = false;
    let rollOverMesh, cubeGeo;
    const objects = [];

    let water, sky, sun;
    const sunParams = { elevation: 2, azimuth: 180 };

    let mobileMoveX = 0, mobileMoveZ = 0, mobileYawDelta = 0, mobilePitchDelta = 0;
    let yaw = 0, pitch = 0;

    /* Textures */
    const tl = new THREE.TextureLoader();
    const textures = {
      arena: tl.load('textures/textura_arena.png'),
      madera: tl.load('textures/textura_wood.jpg'),
      hojas: tl.load('textures/textura_hojas.png'),
      blanco: tl.load('textures/textura_piso.jpg'),
      negro: tl.load('textures/textura_tec_negra.png'),
      ladrillo: tl.load('textures/textura_brick_2.jpg')
    };
    Object.values(textures).forEach(t => t.colorSpace = THREE.SRGBColorSpace);

    /* Params for GUI */
    const cubeParams = { textura: 'madera' };

    /* ----- INIT & MAIN ----- */
    init();
    animate();

    function init() {
      /* Scene */
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);
      scene.add(new THREE.AmbientLight(0x606060));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(1, 0.75, 0.5).normalize();
      scene.add(dirLight);

      /* Grid & ground */
      cubeGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
      rollOverMesh = new THREE.Mesh(cubeGeo, new THREE.MeshBasicMaterial({ color: 0x44ff00, opacity: .5, transparent: true }));
      scene.add(rollOverMesh);
      scene.add(new THREE.GridHelper(1000, 1000 / voxelSize));
      const planeGeo = new THREE.PlaneGeometry(1000, 1000);
      planeGeo.rotateX(-Math.PI / 2);
      plane = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ visible: false }));
      plane.frustumCulled = false;
      scene.add(plane);
      objects.push(plane);

      pointer = new THREE.Vector2();
      raycaster = new THREE.Raycaster();

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new PointerLockControls(camera, document.body);
      scene.add(controls.getObject());
      controls.getObject().position.set(0, voxelSize * 2, 0);

      if (!isMobile) {
        document.getElementById('blocker').addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => document.getElementById('blocker').classList.add('hidden'));
        controls.addEventListener('unlock', () => document.getElementById('blocker').classList.remove('hidden'));
      } else {
        document.getElementById('blocker').classList.add('hidden');
        document.getElementById('joystick-container').classList.remove('hidden');
        document.getElementById('crosshair').classList.add('hidden');
        document.getElementById('addCubeBtn').classList.remove('hidden');
        yaw = camera.rotation.y;
        pitch = camera.rotation.x;
        setupMobileJoysticks();
      }

      /* Events */
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('resize', onResize);
      document.getElementById('copyBtn').addEventListener('click', exportCubes);
      document.getElementById('addCubeBtn').addEventListener('click', addCubeMobile);
      // For mobile deletion via tap (optional)
      renderer.domElement.addEventListener('touchend', e => {
        if (e.touches.length === 0) onPointerDown(e.changedTouches[0]);
      });

      /* Water & sky */
      const waterGeo = new THREE.PlaneGeometry(10000, 10000);
      water = new Water(waterGeo, {
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: tl.load('textures/waternormals.jpg', t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; }),
        sunDirection: new THREE.Vector3(),
        sunColor: 0xffffff,
        waterColor: 0x144fff,
        distortionScale: 3.7,
        fog: scene.fog !== undefined
      });
      water.rotation.x = -Math.PI / 2;
      water.position.y = 2;
      scene.add(water);

      sky = new Sky();
      sky.scale.setScalar(10000);
      scene.add(sky);
      sun = new THREE.Vector3();
      updateSun();

      /* GUI */
      const gui = new GUI();
      gui.addColor({ water: '#144fff' }, 'water').name('Color del agua').onChange(v => water.material.uniforms.waterColor.value.set(v));
      gui.add(cubeParams, 'textura', Object.keys(textures)).name('Textura cubo').onChange(v => cubeParams.textura = v);
      gui.add({ exportarJSON: exportCubes }, 'exportarJSON').name('ðŸ“‹ Copiar JSON cubos');

      /* Demo */
      cargarDesdeJSON([
        { x: -210, y: 10, z: -310, textura: 'arena' },
        { x: -170, y: 10, z: -370, textura: 'arena' }
      ]);
    }

    /* ----- EVENTS ----- */
    function onKeyDown(e) {
      switch (e.code) {
        case 'KeyW':
          moveFlags.forward = true;
          break;
        case 'KeyS':
          moveFlags.backward = true;
          break;
        case 'KeyA':
          moveFlags.left = true;
          break;
        case 'KeyD':
          moveFlags.right = true;
          break;
        case 'KeyQ':
          moveFlags.up = true;
          break;
        case 'KeyE':
          moveFlags.down = true;
          break;
        case 'ShiftLeft':
          isShiftDown = true;
          break;
      }
    }

    function onKeyUp(e) {
      switch (e.code) {
        case 'KeyW':
          moveFlags.forward = false;
          break;
        case 'KeyS':
          moveFlags.backward = false;
          break;
        case 'KeyA':
          moveFlags.left = false;
          break;
        case 'KeyD':
          moveFlags.right = false;
          break;
        case 'KeyQ':
          moveFlags.up = false;
          break;
        case 'KeyE':
          moveFlags.down = false;
          break;
        case 'ShiftLeft':
          isShiftDown = false;
          break;
      }
    }

    function onPointerMove(e) {
      pointer.set((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
      raycaster.setFromCamera(pointer, camera);
      const hit = raycaster.intersectObjects(objects, false)[0];
      if (hit) {
        rollOverMesh.position.copy(snap(hit.point.add(hit.face.normal)));
      }
    }

    function createVoxelAt(pos) {
      if (objects.some(o => o !== plane && o.position.equals(pos))) return; // evita duplicados
      const voxel = new THREE.Mesh(cubeGeo, new THREE.MeshLambertMaterial({ map: textures[cubeParams.textura], color: 0xffffff }));
      voxel.position.copy(pos);
      scene.add(voxel);
      objects.push(voxel);
    }

    function onPointerDown(e) {
      // En mÃ³viles la creaciÃ³n de cubos se controla con el botÃ³n dedicado
      if (isMobile) return;

      pointer.set((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
      raycaster.setFromCamera(pointer, camera);
      const hit = raycaster.intersectObjects(objects, false)[0];
      if (!hit) return;

      if (isShiftDown && hit.object !== plane) {
        // eliminar
        scene.remove(hit.object);
        objects.splice(objects.indexOf(hit.object), 1);
        return;
      }

      const pos = rollOverMesh.position.clone();
      createVoxelAt(pos);
    }

    function addCubeMobile() {
      // Lanza un rayo desde el centro de la pantalla para colocar el cubo delante del jugador
      pointer.set(0, 0);
      raycaster.setFromCamera(pointer, camera);
      const hit = raycaster.intersectObjects(objects, false)[0];
      let pos;
      if (hit) {
        pos = snap(hit.point.add(hit.face.normal));
      } else {
        // si no hay colisiÃ³n con nada, coloca a 2 voxels delante del jugador
        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        pos = camera.position.clone().addScaledVector(dir, voxelSize * 2);
        pos = snap(pos);
      }
      createVoxelAt(pos);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /* ----- JOYSTICKS ----- */
    function setupMobileJoysticks() {
      const lBase = document.getElementById('left-joystick');
      const lKnob = document.getElementById('left-knob');
      const rBase = document.getElementById('right-joystick');
      const rKnob = document.getElementById('right-knob');
      const max = 50;
      const clamp = (v) => Math.max(-max, Math.min(max, v));
      const reset = k => k.style.transform = 'translate(-50%,-50%)';

      let lSX = 0, lSY = 0, lAct = false;
      lBase.addEventListener('touchstart', e => {
        const t = e.touches[0];
        lAct = true;
        lSX = t.clientX;
        lSY = t.clientY;
      }, { passive: true });

      lBase.addEventListener('touchmove', e => {
        if (!lAct) return;
        e.preventDefault();
        const t = e.touches[0];
        const dx = clamp(t.clientX - lSX);
        const dy = clamp(t.clientY - lSY);
        lKnob.style.transform = `translate(calc(-50% + ${dx}px),calc(-50% + ${dy}px))`;
        mobileMoveX = dx / max;
        mobileMoveZ = dy / max;
      }, { passive: false });

      lBase.addEventListener('touchend', () => {
        lAct = false;
        reset(lKnob);
        mobileMoveX = mobileMoveZ = 0;
      });

      let rSX = 0, rSY = 0, rAct = false;
      rBase.addEventListener('touchstart', e => {
        const t = e.touches[0];
        rAct = true;
        rSX = t.clientX;
        rSY = t.clientY;
      }, { passive: true });

      rBase.addEventListener('touchmove', e => {
        if (!rAct) return;
        e.preventDefault();
        const t = e.touches[0];
        const dx = clamp(t.clientX - rSX);
        const dy = clamp(t.clientY - rSY);
        rKnob.style.transform = `translate(calc(-50% + ${dx}px),calc(-50% + ${dy}px))`;
        mobileYawDelta = dx / max;
        mobilePitchDelta = dy / max;
      }, { passive: false });

      rBase.addEventListener('touchend', () => {
        rAct = false;
        reset(rKnob);
        mobileYawDelta = mobilePitchDelta = 0;
      });
    }

    /* ----- HELPERS ----- */
    function snap(v) {
      return v.clone().divideScalar(voxelSize).floor().multiplyScalar(voxelSize).addScalar(voxelSize / 2);
    }

    function cargarDesdeJSON(arr) {
      arr.forEach(({ x, y, z, textura }) => {
        const voxel = new THREE.Mesh(cubeGeo, new THREE.MeshLambertMaterial({ map: textures[textura] || null, color: 0xffffff }));
        voxel.position.set(x, y, z);
        scene.add(voxel);
        objects.push(voxel);
      });
    }

    function exportCubes() {
      const data = objects
        .filter(o => o !== plane)
        .map(o => {
          const key = Object.entries(textures).find(([k, v]) => v === o.material.map)?.[0] || 'desconocida';
          return { x: o.position.x, y: o.position.y, z: o.position.z, textura: key };
        });
      navigator.clipboard.writeText(JSON.stringify(data, null, 2))
        .then(() => alert('JSON copiado'))
        .catch(console.error);
    }

    function updateSun() {
      const phi = THREE.MathUtils.degToRad(90 - sunParams.elevation);
      const theta = THREE.MathUtils.degToRad(sunParams.azimuth);
      sun.setFromSphericalCoords(1, phi, theta);
      sky.material.uniforms.sunPosition.value.copy(sun);
      water.material.uniforms.sunDirection.value.copy(sun).normalize();
    }

    /* ----- LOOP ----- */
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      if (!isMobile && controls.isLocked) {
        velocity.set(0, 0, 0);
        if (moveFlags.forward) velocity.z -= DESKTOP_SPEED * dt;
        if (moveFlags.backward) velocity.z += DESKTOP_SPEED * dt;
        if (moveFlags.left) velocity.x -= DESKTOP_SPEED * dt;
        if (moveFlags.right) velocity.x += DESKTOP_SPEED * dt;
        if (moveFlags.up) velocity.y += DESKTOP_SPEED * dt;
        if (moveFlags.down) velocity.y -= DESKTOP_SPEED * dt;
        controls.moveRight(velocity.x * dt);
        controls.moveForward(velocity.z * dt);
        controls.getObject().position.y += velocity.y * dt;
      }

      if (isMobile) {
        const lookSpeed = 2.5;
        yaw -= mobileYawDelta * lookSpeed * dt;
        pitch -= mobilePitchDelta * lookSpeed * dt;
        pitch = THREE.MathUtils.clamp(pitch, -Math.PI / 2 + 0.1, Math.PI / 2 - 0.1);
        camera.rotation.order = 'YXZ';
        camera.rotation.y = yaw;
        camera.rotation.x = pitch;

        const fwd = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        camera.position.addScaledVector(fwd, mobileMoveZ * MOBILE_SPEED * dt);
        camera.position.addScaledVector(right, mobileMoveX * MOBILE_SPEED * dt);
        camera.position.y = 5;
        camera.position.x = THREE.MathUtils.clamp(camera.position.x, -500, 500);
        camera.position.z = THREE.MathUtils.clamp(camera.position.z, -500, 500);
      }

      if (water) water.material.uniforms.time.value += dt;
      renderer.render(scene, camera);
    }
  </script>
</body>

</html>
