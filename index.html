<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js - voxel FPS con ocean shader</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #f0f0f0;
    }

    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 20px;
      z-index: 100;
    }

    #instructions {
      text-align: center;
      max-width: 600px;
    }

    #copyBtn,
    #addCubeBtn {
      position: fixed;
      z-index: 200;
      padding: 10px 15px;
      font-size: 14px;
      background: #08f;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    #copyBtn {
      top: 10px;
      right: 10px;
    }

    #addCubeBtn {
      bottom: 20px;
      right: 20px;
    }

    #joystickContainer {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 200;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
</head>

<body>
  <div id="blocker">
    <div id="instructions">
      <p><b>Haz click para comenzar</b></p>
      <p>W A S D para moverse, mouse para mirar</p>
      <p>Click: añadir cubo, Shift + click: eliminar cubo</p>
      <p>Q E para subir/bajar</p>
      <p>ESC pausa/configuración</p>
    </div>
  </div>
  <button id="copyBtn">Copiar coordenadas</button>
  <button id="addCubeBtn">➕ Cubo</button>
  <div id="joystickContainer"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.module.js",
        "three/addons/": "./jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { Water } from 'three/addons/objects/Water.js';
    import { Sky } from 'three/addons/objects/Sky.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

    const voxelSize = 20;
    let camera, scene, renderer, controls;
    let plane, pointer, raycaster, isShiftDown = false;
    let rollOverMesh, cubeGeo, cubeMaterial;
    const objects = [];
    const move = { forward: false, backward: false, left: false, right: false, up: false, down: false };
    const velocity = new THREE.Vector3();
    const speed = 400;
    let water, sky, sun;
    const parameters = { elevation: 2, azimuth: 180 };
    const textureLoader = new THREE.TextureLoader();

    const textures = {
      arena: textureLoader.load('textures/textura_arena.png'),
      madera: textureLoader.load('textures/textura_wood.jpg'),
      hojas: textureLoader.load('textures/textura_hojas.png'),
      blanco: textureLoader.load('textures/textura_piso.jpg'),
      negro: textureLoader.load('textures/textura_tec_negro.png'),
      ladrillo: textureLoader.load('textures/textura_brick_2.jpg'),
      quest3: textureLoader.load('textures/imagen_metaquest.png')
    };
    for (const key in textures) textures[key].colorSpace = THREE.SRGBColorSpace;

    const gui = new GUI();
    const cubeParams = { textura: 'madera' };

    init();
    if (/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) setupMobileControls();
    animate();

    function init() {
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      scene.add(new THREE.AmbientLight(0x606060));
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 0.75, 0.5).normalize();
      scene.add(directionalLight);

      cubeGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
      cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, map: textures.arena });

      const rollOverGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
      const rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0x44FF00, opacity: 0.5, transparent: true });
      rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
      scene.add(rollOverMesh);

      const grid = new THREE.GridHelper(1000, 1000 / voxelSize);
      scene.add(grid);

      const geometry = new THREE.PlaneGeometry(1000, 1000);
      geometry.rotateX(-Math.PI / 2);
      plane = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ visible: false }));
      plane.frustumCulled = false;
      scene.add(plane);
      objects.push(plane);

      pointer = new THREE.Vector2();
      raycaster = new THREE.Raycaster();

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new PointerLockControls(camera, document.body);
      scene.add(controls.getObject());
      controls.getObject().position.set(0, voxelSize * 2, 0);

      document.getElementById('blocker').addEventListener('click', () => controls.lock());
      controls.addEventListener('lock', () => document.getElementById('blocker').style.display = 'none');
      controls.addEventListener('unlock', () => document.getElementById('blocker').style.display = 'flex');

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('resize', onWindowResize);

      document.getElementById('copyBtn').addEventListener('click', () => {
        const positions = objects.filter(obj => obj !== plane).map(obj => ({ x: obj.position.x, y: obj.position.y, z: obj.position.z }));
        navigator.clipboard.writeText(JSON.stringify(positions, null, 2)).then(() => alert('Coordenadas copiadas'));
      });

      const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
      water = new Water(waterGeometry, {
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: textureLoader.load('textures/waternormals.jpg', t => t.wrapS = t.wrapT = THREE.RepeatWrapping),
        sunDirection: new THREE.Vector3(),
        sunColor: 0xffffff,
        waterColor: 0x144fff,
        distortionScale: 3.7,
        fog: scene.fog !== undefined
      });
      water.rotation.x = -Math.PI / 2;
      water.position.y = 2;
      scene.add(water);

      gui.addColor({ color: '#144fff' }, 'color').name('Color del agua').onChange(value => water.material.uniforms['waterColor'].value.set(value));
      gui.add(cubeParams, 'textura', Object.keys(textures)).name('Textura del cubo');

      sky = new Sky();
      sky.scale.setScalar(10000);
      scene.add(sky);
      sun = new THREE.Vector3();
      sky.material.uniforms['turbidity'].value = 10;
      sky.material.uniforms['rayleigh'].value = 2;
      sky.material.uniforms['mieCoefficient'].value = 0.005;
      sky.material.uniforms['mieDirectionalG'].value = 0.8;

      const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
      const theta = THREE.MathUtils.degToRad(parameters.azimuth);
      sun.setFromSphericalCoords(1, phi, theta);
      sky.material.uniforms['sunPosition'].value.copy(sun);
      water.material.uniforms['sunDirection'].value.copy(sun).normalize();
    }

    function setupMobileControls() {
      const joystick = nipplejs.create({
        zone: document.getElementById('joystickContainer'),
        mode: 'static',
        position: { left: '50px', bottom: '50px' },
        color: 'blue'
      });

      joystick.on('move', (evt, data) => {
        const angle = data.angle.degree;
        move.forward = angle >= 45 && angle < 135;
        move.backward = angle >= 225 && angle < 315;
        move.left = angle >= 135 && angle < 225;
        move.right = (angle >= 0 && angle < 45) || (angle >= 315 && angle <= 360);
      });

      joystick.on('end', () => {
        move.forward = move.backward = move.left = move.right = false;
      });

      document.getElementById('addCubeBtn').addEventListener('click', () => {
        const snapped = rollOverMesh.position.clone();
        const exists = objects.some(obj => obj !== plane && obj.position.equals(snapped));
        if (!exists) {
          const voxel = new THREE.Mesh(cubeGeo, new THREE.MeshLambertMaterial({ map: textures[cubeParams.textura], color: 0xffffff }));
          voxel.position.copy(snapped);
          scene.add(voxel);
          objects.push(voxel);
        }
      });
    }

    function onPointerMove(event) {
      pointer.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(objects, false);
      if (intersects.length > 0) {
        const intersect = intersects[0];
        const snapped = getSnappedPosition(intersect.point.add(intersect.face.normal), voxelSize);
        rollOverMesh.position.copy(snapped);
      }
    }

    function onPointerDown(event) {
      pointer.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(objects, false);
      if (intersects.length > 0) {
        const intersect = intersects[0];
        if (isShiftDown && intersect.object !== plane) {
          scene.remove(intersect.object);
          const index = objects.indexOf(intersect.object);
          if (index !== -1) objects.splice(index, 1);
        }
      }
    }

    function onKeyDown(event) {
      switch (event.code) {
        case 'KeyW': move.forward = true; break;
        case 'KeyS': move.backward = true; break;
        case 'KeyA': move.left = true; break;
        case 'KeyD': move.right = true; break;
        case 'KeyQ': move.up = true; break;
        case 'KeyE': move.down = true; break;
        case 'ShiftLeft': isShiftDown = true; break;
      }
    }

    function onKeyUp(event) {
      switch (event.code) {
        case 'KeyW': move.forward = false; break;
        case 'KeyS': move.backward = false; break;
        case 'KeyA': move.left = false; break;
        case 'KeyD': move.right = false; break;
        case 'KeyQ': move.up = false; break;
        case 'KeyE': move.down = false; break;
        case 'ShiftLeft': isShiftDown = false; break;
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function getSnappedPosition(position, size) {
      return position.clone().divideScalar(size).floor().multiplyScalar(size).addScalar(size / 2);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (controls.isLocked) {
        const delta = 0.05;
        velocity.set(0, 0, 0);
        if (move.forward) velocity.z -= speed * delta;
        if (move.backward) velocity.z += speed * delta;
        if (move.left) velocity.x -= speed * delta;
        if (move.right) velocity.x += speed * delta;
        if (move.up) velocity.y += speed * delta;
        if (move.down) velocity.y -= speed * delta;
        controls.moveRight(velocity.x * delta);
        controls.moveForward(velocity.z * delta);
        controls.getObject().position.y += velocity.y * delta;
      }
      if (water) {
        water.material.uniforms['time'].value += 1.0 / 60.0;
      }
      renderer.render(scene, camera);
    }
  </script>
</body>

</html>
