<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js - voxel FPS con ocean shader</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #f0f0f0;
    }

    /* Crosshair */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 10px;
      height: 10px;
      border: 2px solid rgba(255, 255, 255, .8);
      border-radius: 50%;
      pointer-events: none;
      z-index: 5;
    }

    .hidden {
      display: none !important;
    }

    /* Joysticks */
    .joystick {
      position: fixed;
      width: 120px;
      height: 120px;
      background: rgba(0, 0, 0, .35);
      border: 2px solid rgba(255, 255, 255, .5);
      border-radius: 50%;
      touch-action: none;
      user-select: none;
    }

    #left-joystick {
      left: 20px;
      bottom: 20px;
    }

    #right-joystick {
      right: 20px;
      bottom: 20px;
    }

    .knob {
      position: absolute;
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, .7);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    /* Overlay desktop */
    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, .5);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 20px;
      z-index: 100;
    }

    #instructions {
      text-align: center;
      max-width: 600px;
    }

    #copyBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 200;
      padding: 10px 15px;
      font-size: 14px;
      background: #08f;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    /* Bot√≥n ‚ÄúA√±adir cubo‚Äù solo m√≥vil */
    #addCubeBtn {
      position: fixed;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 120px;
      border-radius: 60px;
      background: #08f;
      color: #fff;
      font-size: 16px;
      border: none;
      z-index: 300;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
    }

    /* ‚Üë / ‚Üì en eje Y */
    .yBtn {
      position: fixed;
      right: 20px;
      width: 100px;
      height: 60px;
      background: #08f;
      color: #fff;
      font-size: 18px;
      border: none;
      border-radius: 10px;
      z-index: 300;
      user-select: none;
      touch-action: manipulation;
    }

    #upBtn {
      bottom: 180px;
    }

    /* encima del joystick derecho */
    #downBtn {
      bottom: 250px;
    }

    /* un poco m√°s arriba */
  </style>
</head>

<body>
  <div id="crosshair"></div>

  <!-- Joystick container -->
  <div id="joystick-container" class="hidden">
    <div id="left-joystick" class="joystick">
      <div id="left-knob" class="knob"></div>
    </div>
    <div id="right-joystick" class="joystick">
      <div id="right-knob" class="knob"></div>
    </div>
  </div>

  <!-- Overlay desktop -->
  <div id="blocker">
    <div id="instructions">
      <p><b>Haz clic para comenzar</b></p>
      <p>W A S D para moverse, mouse para mirar</p>
      <p>Click: a√±adir cubo, Shift+Click: eliminar cubo</p>
      <p>Q / E para subir/bajar</p>
      <p>ESC pausa/configuraci√≥n</p>
    </div>
  </div>

  <button id="copyBtn">Copiar coordenadas</button>

  <!-- Botones m√≥viles -->
  <button id="addCubeBtn" class="hidden">A√±adir&nbsp;Cubo</button>
  <button id="upBtn" class="yBtn hidden">‚Üë Y</button>
  <button id="downBtn" class="yBtn hidden">‚Üì Y</button>

  <input id="jsonInput" type="file" accept=".json,application/json" hidden>


  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.module.js",
        "three/addons/": "./jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js?module';
    import { Water } from 'three/addons/objects/Water.js';
    import { Sky } from 'three/addons/objects/Sky.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

    /* ----- CONSTANTES & GLOBALES ----- */
    const voxelSize = 20;
    const moveFlags = { forward: false, backward: false, left: false, right: false, up: false, down: false };
    const velocity = new THREE.Vector3();
    const DESKTOP_SPEED = 10000;
    const MOBILE_SPEED = 300;

    const isMobile = window.matchMedia('(pointer: coarse)').matches;
    const clock = new THREE.Clock();

    let camera, scene, renderer, controls;
    let plane, pointer, raycaster, isShiftDown = false;
    let rollOverMesh, cubeGeo;
    const objects = [];

    let water, sky, sun;
    const sunParams = { elevation: 2, azimuth: 180 };

    /* Movimiento m√≥vil */
    let mobileMoveX = 0, mobileMoveZ = 0;
    let mobileYawDelta = 0, mobilePitchDelta = 0;
    let mobileMoveY = 0;
    let yaw = 0, pitch = 0;

    /* Texturas */
    const tl = new THREE.TextureLoader();
    const textures = {
      arena: tl.load('textures/textura_arena.png'),
      madera: tl.load('textures/textura_wood.jpg'),
      hojas: tl.load('textures/textura_hojas.png'),
      blanco: tl.load('textures/textura_piso.jpg'),
      negro: tl.load('textures/textura_tec_negra.png'),
      ladrillo: tl.load('textures/textura_brick_2.jpg'),
      baldosaGris: tl.load('textures/textura_baldosaGris.jpg'),
      pisoVerde: tl.load('textures/textura_pisoVerde.jpg'),
      tejasAzules: tl.load('textures/textura_tejasAzules.jpg'),
      metal1: tl.load('textures/textura_metal1.jpg'),
      ladrillo2: tl.load('textures/textura_ladrillo2.jpg'),
      ladrillo3: tl.load('textures/textura_ladrillo3.jpg'),
      ladrillo4: tl.load('textures/textura_ladrillo4.jpg'),
      baldosaCafe: tl.load('textures/textura_baldosaCafe.jpg'),
      corteza: tl.load('textures/textura_corteza2.jpg'),
      madera2: tl.load('textures/textura_madera2.jpg'),
      madera3: tl.load('textures/textura_madera3.jpg'),
      gafas: tl.load('textures/textura_gafas.png')

    };
    Object.values(textures).forEach(t => t.colorSpace = THREE.SRGBColorSpace);

    const cubeParams = { textura: 'madera' };

    /* ----- INIT & MAIN ----- */
    init();
    animate();

    function init() {
      /* Escena & c√°mara */
      camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 1, 10000);
      scene = new THREE.Scene(); scene.background = new THREE.Color(0xf0f0f0);
      scene.add(new THREE.AmbientLight(0x606060));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(1, 0.75, 0.5).normalize(); scene.add(dirLight);

      /* Voxel helper */
      cubeGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
      rollOverMesh = new THREE.Mesh(cubeGeo, new THREE.MeshBasicMaterial({ color: 0x44ff00, opacity: .5, transparent: true }));
      scene.add(rollOverMesh);

      /* Suelo */
      scene.add(new THREE.GridHelper(1000, 1000 / voxelSize));
      const planeGeo = new THREE.PlaneGeometry(1000, 1000); planeGeo.rotateX(-Math.PI / 2);
      plane = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ visible: false }));
      plane.frustumCulled = false; scene.add(plane); objects.push(plane);

      pointer = new THREE.Vector2();
      raycaster = new THREE.Raycaster();

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight); document.body.appendChild(renderer.domElement);

      controls = new PointerLockControls(camera, document.body);
      scene.add(controls.getObject());
      controls.getObject().position.set(0, voxelSize * 2, 0);

      /* Interfaz seg√∫n dispositivo */
      if (!isMobile) {
        document.getElementById('blocker').addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => document.getElementById('blocker').classList.add('hidden'));
        controls.addEventListener('unlock', () => document.getElementById('blocker').classList.remove('hidden'));
      } else {
        document.getElementById('blocker').classList.add('hidden');
        document.getElementById('joystick-container').classList.remove('hidden');
        document.getElementById('crosshair').classList.add('hidden');
        document.getElementById('addCubeBtn').classList.remove('hidden');
        document.getElementById('upBtn').classList.remove('hidden');
        document.getElementById('downBtn').classList.remove('hidden');
        yaw = camera.rotation.y; pitch = camera.rotation.x;
        setupMobileJoysticks();
        setupYButtons();
      }

      /* Eventos comunes */
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('resize', onResize);
      document.getElementById('copyBtn').addEventListener('click', exportCubes);
      document.getElementById('addCubeBtn').addEventListener('click', addCubeMobile);
      renderer.domElement.addEventListener('touchend', e => {
        if (e.touches.length === 0) onPointerDown(e.changedTouches[0]);
      });

      /* --------- Cargar JSON desde archivo --------- */
      document.getElementById('jsonInput').addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = evt => {
          try {
            const data = JSON.parse(evt.target.result);

            if (!Array.isArray(data)) {
              alert('El JSON debe ser un array de objetos con {x,y,z,textura}');
              return;
            }

            cargarDesdeJSON(data);          // ‚Üê tu funci√≥n ya existente
            alert('Voxeles cargados correctamente');
          } catch (err) {
            console.error(err);
            alert('JSON no v√°lido');
          }
        };
        reader.readAsText(file);
      });


      /* Agua & cielo */
      const waterGeo = new THREE.PlaneGeometry(10000, 10000);
      water = new Water(waterGeo, {
        textureWidth: 512, textureHeight: 512,
        waterNormals: tl.load('textures/waternormals.jpg', t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; }),
        sunDirection: new THREE.Vector3(), sunColor: 0xffffff, waterColor: 0x144fff,
        distortionScale: 3.7, fog: scene.fog !== undefined
      });
      water.rotation.x = -Math.PI / 2; water.position.y = 2; scene.add(water);

      sky = new Sky(); sky.scale.setScalar(10000); scene.add(sky);
      sun = new THREE.Vector3(); updateSun();

      /* GUI r√°pida */
      const gui = new GUI();
      gui.addColor({ water: '#144fff' }, 'water').name('Color del agua')
        .onChange(v => water.material.uniforms.waterColor.value.set(v));
      gui.add(cubeParams, 'textura', Object.keys(textures)).name('Textura cubo');
      gui.add({ exportarJSON: exportCubes }, 'exportarJSON').name('üíæ Descargar escena en .json');
      /* --- GUI (a√±√°delo junto a tus otros gui.add) --- */
      const fileChooser = document.getElementById('jsonInput');

      /* 1. Bot√≥n en el panel */
      gui.add({ importarJSON() { fileChooser.click(); } }, 'importarJSON')
        .name('üìÇ cargar escena en .json');

      /* 2. Lector del archivo seleccionado */
      fileChooser.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = evt => {
          try {
            const data = JSON.parse(evt.target.result);
            if (!Array.isArray(data)) {
              alert('El JSON debe ser un array de objetos con {x,y,z,textura}');
              return;
            }
            cargarDesdeJSON(data);
            alert('Voxeles importados');
          } catch (err) {
            console.error(err);
            alert('JSON no v√°lido');
          }
        };
        reader.readAsText(file);
      });



      fetch('./cubes.json')
        .then(r => r.json())            // Convierte la respuesta a objeto JS
        .then(cargarDesdeJSON)          // Reconstruye la escena
        .catch(err => console.error('No se pudo cargar cubes.json', err));
    }

    /* ----- INPUT TECLADO ----- */
    function onKeyDown(e) {
      switch (e.code) {
        case 'KeyW': moveFlags.forward = true; break;
        case 'KeyS': moveFlags.backward = true; break;
        case 'KeyA': moveFlags.left = true; break;
        case 'KeyD': moveFlags.right = true; break;
        case 'KeyQ': moveFlags.up = true; break;
        case 'KeyE': moveFlags.down = true; break;
        case 'ShiftLeft': isShiftDown = true; break;
      }
    }
    function onKeyUp(e) {
      switch (e.code) {
        case 'KeyW': moveFlags.forward = false; break;
        case 'KeyS': moveFlags.backward = false; break;
        case 'KeyA': moveFlags.left = false; break;
        case 'KeyD': moveFlags.right = false; break;
        case 'KeyQ': moveFlags.up = false; break;
        case 'KeyE': moveFlags.down = false; break;
        case 'ShiftLeft': isShiftDown = false; break;
      }
    }

    /* ----- MOUSE / TOUCH PARA CUBOS ----- */
    function onPointerMove(e) {
      pointer.set((e.clientX / innerWidth) * 2 - 1, -(e.clientY / innerHeight) * 2 + 1);
      raycaster.setFromCamera(pointer, camera);
      const hit = raycaster.intersectObjects(objects, false)[0];
      if (hit) { rollOverMesh.position.copy(snap(hit.point.add(hit.face.normal))); }
    }
    function onPointerDown(e) {
      if (isMobile) return; // cubos en m√≥vil via bot√≥n
      pointer.set((e.clientX / innerWidth) * 2 - 1, -(e.clientY / innerHeight) * 2 + 1);
      raycaster.setFromCamera(pointer, camera);
      const hit = raycaster.intersectObjects(objects, false)[0];
      if (!hit) return;
      if (isShiftDown && hit.object !== plane) { // eliminar
        scene.remove(hit.object); objects.splice(objects.indexOf(hit.object), 1); return;
      }
      createVoxelAt(rollOverMesh.position.clone());
    }
    function createVoxelAt(pos) {
      if (objects.some(o => o !== plane && o.position.equals(pos))) return;
      const voxel = new THREE.Mesh(cubeGeo, new THREE.MeshLambertMaterial({ map: textures[cubeParams.textura] }));
      voxel.position.copy(pos); scene.add(voxel); objects.push(voxel);
    }
    function addCubeMobile() {
      // 1Ô∏è‚É£ Lanza un rayo desde el centro de la pantalla
      pointer.set(0, 0);
      raycaster.setFromCamera(pointer, camera);

      // 2Ô∏è‚É£ Incluimos el plano-suelo en la lista de posibles impactos
      const hit = raycaster.intersectObjects(objects.concat(plane), false)[0];

      let pos;
      if (hit) {
        // 3Ô∏è‚É£ Caso A: estamos mirando a algo (cubo o suelo)
        // Desplazamos medio voxel en la normal para ‚Äúpegar‚Äù el nuevo cubo
        const nrm = hit.face.normal.clone();                 // normal de la cara
        const p = hit.point.clone().addScaledVector(nrm, voxelSize / 2 + 0.01);
        pos = snap(p);
      } else {
        // 4Ô∏è‚É£ Caso B: no hay nada enfrente (mirando al cielo)
        // Colocamos el cubo a dos celdas frente a la c√°mara
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        pos = snap(camera.position.clone().addScaledVector(dir, voxelSize * 2));
      }

      // 5Ô∏è‚É£ Seguridad: nunca por debajo del plano
      pos.y = Math.max(pos.y, voxelSize / 2);

      // 6Ô∏è‚É£ Creamos el voxel (createVoxelAt evita duplicados)
      createVoxelAt(pos);
    }


    /* ---------- PLACEHOLDER M√ìVIL ---------- */
    function updateRollOverMobile() {
      // Rayo desde el centro de pantalla
      pointer.set(0, 0);
      raycaster.setFromCamera(pointer, camera);

      // Incluimos el plano-suelo para no ‚Äúfallar‚Äù
      const hit = raycaster.intersectObjects(objects.concat(plane), false)[0];

      let pos;
      if (hit) {
        // Cara golpeada ‚Üí desplazar media celda en la normal
        pos = hit.point
          .clone()
          .addScaledVector(hit.face.normal, voxelSize / 2 + 0.01);
        pos = snap(pos);
      } else {
        // Nada delante (mirando al cielo) ‚Üí 2 celdas frente a la c√°mara
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        pos = snap(
          camera.position.clone().addScaledVector(dir, voxelSize * 2)
        );
      }

      // Nunca por debajo del suelo
      pos.y = Math.max(pos.y, voxelSize / 2);

      rollOverMesh.position.copy(pos);
    }

    /* ----- JOYSTICKS ----- */
    function setupMobileJoysticks() {
      const lBase = document.getElementById('left-joystick'), lKnob = document.getElementById('left-knob');
      const rBase = document.getElementById('right-joystick'), rKnob = document.getElementById('right-knob');
      const max = 50, clamp = v => Math.max(-max, Math.min(max, v)), reset = k => k.style.transform = 'translate(-50%,-50%)';

      /* Joystick izquierda: mover X/Z */
      let lSX = 0, lSY = 0, lAct = false;
      lBase.addEventListener('touchstart', e => {
        const t = e.touches[0];
        lAct = true;
        lSX = t.clientX;
        lSY = t.clientY;
      }, { passive: true });

      lBase.addEventListener('touchmove', e => {
        if (!lAct) return;
        e.preventDefault();

        const t = e.touches[0];
        const dx = clamp(t.clientX - lSX);
        const dy = clamp(t.clientY - lSY);

        lKnob.style.transform =
          `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

        mobileMoveX = dx / max;  // izquierda / derecha sin cambios
        mobileMoveZ = -dy / max;  // ‚Üê inversi√≥n: arriba ‚Üí positivo (avanzar)
      }, { passive: false });

      lBase.addEventListener('touchend', () => {
        lAct = false;
        reset(lKnob);
        mobileMoveX = mobileMoveZ = 0;
      });

      /* Joystick derecha: mirar */
      let rSX = 0, rSY = 0, rAct = false;
      rBase.addEventListener('touchstart', e => { const t = e.touches[0]; rAct = true; rSX = t.clientX; rSY = t.clientY; }, { passive: true });
      rBase.addEventListener('touchmove', e => {
        if (!rAct) return; e.preventDefault();
        const t = e.touches[0], dx = clamp(t.clientX - rSX), dy = clamp(t.clientY - rSY);
        rKnob.style.transform = `translate(calc(-50% + ${dx}px),calc(-50% + ${dy}px))`;
        mobileYawDelta = dx / max;
        mobilePitchDelta = dy / max;
      }, { passive: false });
      rBase.addEventListener('touchend', () => { rAct = false; reset(rKnob); mobileYawDelta = mobilePitchDelta = 0; });
    }

    /* ----- NUEVOS BOTONES ‚Üë/‚Üì Y ----- */
    function setupYButtons() {
      const up = document.getElementById('upBtn');
      const down = document.getElementById('downBtn');

      /* Helper ‚Üì asocia inicio/fin */
      const bind = (el, dir) => {
        const start = () => mobileMoveY = dir;
        const stop = () => { if (mobileMoveY === dir) mobileMoveY = 0; };
        el.addEventListener('touchstart', start, { passive: true });
        el.addEventListener('touchend', stop);
        el.addEventListener('mousedown', start);   // por si usa mouse en m√≥vil
        el.addEventListener('mouseup', stop);
        el.addEventListener('mouseleave', stop);
      };
      bind(up, +1);
      bind(down, -1);
    }

    /* ----- VARIOS ----- */
    function onResize() { camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }
    function snap(v) { return v.clone().divideScalar(voxelSize).floor().multiplyScalar(voxelSize).addScalar(voxelSize / 2); }

    function cargarDesdeJSON(arr) {
      /* 1Ô∏è‚É£ Eliminar todos los voxeles existentes (mantener el plano) */
      for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        if (obj !== plane) {           // el plano base se conserva
          scene.remove(obj);           // lo quitamos de la escena
          objects.splice(i, 1);        // y del array de colisiones
        }
      }

      /* 2Ô∏è‚É£ Crear los nuevos voxeles desde el JSON */
      arr.forEach(({ x, y, z, textura }) => {
        const mat = new THREE.MeshLambertMaterial({ map: textures[textura] || null });
        const voxel = new THREE.Mesh(cubeGeo, mat);
        voxel.position.set(x, y, z);
        scene.add(voxel);
        objects.push(voxel);
      });
    }

    function exportCubes() {
      // 1. Recopilar datos de los voxeles (igual que antes)
      const data = objects
        .filter(o => o !== plane)
        .map(o => {
          const key =
            Object.entries(textures).find(([k, v]) => v === o.material.map)?.[0] ??
            'desconocida';
          return { x: o.position.x, y: o.position.y, z: o.position.z, textura: key };
        });

      // 2. Convertir a texto JSON con sangr√≠a de 2 espacios
      const json = JSON.stringify(data, null, 2);

      // 3. Crear un Blob y generar una URL temporal
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      // 4. Crear un enlace invisible y ‚Äúclickearlo‚Äù para iniciar la descarga
      const a = document.createElement('a');
      a.href = url;
      // Nombre de archivo con marca de tiempo ISO (sin caracteres inv√°lidos)
      a.download = `voxeles_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();

      // 5. Liberar la URL temporal
      URL.revokeObjectURL(url);
    }

    function updateSun() {
      const phi = THREE.MathUtils.degToRad(90 - sunParams.elevation);
      const theta = THREE.MathUtils.degToRad(sunParams.azimuth);
      sun.setFromSphericalCoords(1, phi, theta);
      sky.material.uniforms.sunPosition.value.copy(sun);
      water.material.uniforms.sunDirection.value.copy(sun).normalize();
    }

    /* ----- LOOP ----- */
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      /* Desktop ‚Üê PointerLock */
      if (!isMobile && controls.isLocked) {
        velocity.set(0, 0, 0);
        if (moveFlags.forward) velocity.z += DESKTOP_SPEED * dt;
        if (moveFlags.backward) velocity.z -= DESKTOP_SPEED * dt;
        if (moveFlags.left) velocity.x -= DESKTOP_SPEED * dt;
        if (moveFlags.right) velocity.x += DESKTOP_SPEED * dt;
        if (moveFlags.up) velocity.y += DESKTOP_SPEED * dt;
        if (moveFlags.down) velocity.y -= DESKTOP_SPEED * dt;
        controls.moveRight(velocity.x * dt);
        controls.moveForward(velocity.z * dt);
        controls.getObject().position.y += velocity.y * dt;
      }

      /* M√≥vil */
      if (isMobile) {
        const lookSpeed = 2.5;
        yaw -= mobileYawDelta * lookSpeed * dt;
        pitch -= mobilePitchDelta * lookSpeed * dt;
        pitch = THREE.MathUtils.clamp(pitch, -Math.PI / 2 + 0.1, Math.PI / 2 - 0.1);
        camera.rotation.order = 'YXZ';
        camera.rotation.y = yaw; camera.rotation.x = pitch;

        const fwd = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        camera.position.addScaledVector(fwd, mobileMoveZ * MOBILE_SPEED * dt);
        camera.position.addScaledVector(right, mobileMoveX * MOBILE_SPEED * dt);
        camera.position.y += mobileMoveY * MOBILE_SPEED * dt;

        /* L√≠mites opcionales */
        camera.position.x = THREE.MathUtils.clamp(camera.position.x, -500, 500);
        camera.position.z = THREE.MathUtils.clamp(camera.position.z, -500, 500);
        camera.position.y = THREE.MathUtils.clamp(camera.position.y, 2, 150);

        updateRollOverMobile();
      }

      if (water) water.material.uniforms.time.value += dt;
      renderer.render(scene, camera);
    }
  </script>
</body>

</html>